"""
我们不可以用加减乘除符号
因此与或非运算就是我们可以用的方式   位运算是基于二进制的
基本运算有7种，与&，或|，非~，左移<<，右移>>
&(按位与)：两位都是1时，结果才为1，否则为0  1(01)&3(11)=1(01)
|(按位或):只有有1个为1就是1，都是0则为0    1(01)|3(11)=3(11)
^（按位异或）：长得一样得0，不一样得1       1(01)^3(11)=2(10)
~(按位求反):对每一位进行取反操作           1(01)~=2(10)
<<(左移):对二进制位上的数向左移动，右边补0   1(01)<<2=4(0100)
对于非负数，有符号右移和无符号右移总是返回相同的结果
>>(有符合右移)：对二进制位上的数向右移N位，丢弃移出的位   4(0100)>>2=1(01)
>>>(无符号右移):对二进制位上的数向右移N位，丢弃移出的位，并使用0在左侧填充   4(0100)>>>2=1(0001)   -2
python没有>>>无符号右移
十进制转二进制
正数：10：
10    0
5      1
2      0
1      1
1010
十进制完成加法：
18+15=？
个、十、百位 的数字分别相加先不管进位的问题：0
个位：8 + 5 = 0
十位：1 + 1 = 2
得到临时结果：20
计算进位的数字：
8 + 5 = 13;
得到进位结果：13
相加得到结果  20+ 13 = 33

如何用二进制完成以上的步骤？      转换成位运算
18(10010)
15(1111)
33(100001)
先不管进位：
10010+01111=11101           第一步：可以转换成异或
考虑进位：
10+10=100                    第二步：与运算后左移一位（10010&01111）<<1=100
相加需要再进一次
11101（29）+100（4）=33所以结果是对的     第三步接着重复之前的步骤

1、11101^100=11001       （11101&100）>>1=1000         11001(1+8+16=25)+1000(8)=33
2、11001^01000=10001          （11001&01000）>>1=10000     10001(17)+10000(16)=33
3、10001^10000=00001          (10001&10000)>>1=100000      100000+1=100001(33)
"""
class Solution:
    def Add(self , num1: int, num2: int) -> int:
        # write code here
        # add表示进位值
        for i in range(32):
            i+=1
            # 将每轮的无进位和与进位值做异或求和
            temp1 = num1 ^ num2
            # 进位值是用与运算产生的
            temp2 = (num1 & num2) << 1
            num1=temp1
            num2=temp2
#             # 更新sum为新的和(处理负数问题)
#             sum = temp & 0xFFFFFFFF
        return num1+num2