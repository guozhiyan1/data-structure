"""
二进制中1的个数
python关注负数的差异性
十进制转二进制
正数：10：
10    0
5      1
2      0
1      1
1010
二进制的最高位是符号位：0表示正数，1表示负数
00 00 00 11 -> 3
10 00 00 11 -> -3  [可以看出有一位为符号位]
反码：正数反码就是正数
负数的反码：原码符号位不变，其他位取反
补码：
正数的补码就是原码
负数的补码是+1：0+1=1；01+1=10
0的反码、补码都是0
负数用二进制标识（原码--反码+补码）：
1是    0000 0000 0000 0000 0000 0000 0000 0001
反码    1111 1111 1111 1111 1111 1111 1111 1110
加1    1111 1111 1111 1111 1111 1111 1111 1111  （-1）

13     0000 0000 0000 0000 0000 0000 0000 1101
取反：  1111 1111 1111 1111 1111 1111 1111 0010
补码    1111 1111 1111 1111 1111 1111 1111 0011   （-13）

如何求1的个数？
> 0, 统计1的个数 2、< 0, 转成正数，统计0的个数，32-0的个数
3    0000 0000 0000 0000 0000 0000 0000 0011
-3   1111 1111 1111 1111 1111 1111 1111 1101   （-3）
> 0, 统计1的个数 2、< 0, 转成正数，统计0的个数，32-0的个数
"""
class Solution:
    def NumberOf1(self , n: int) -> int:
        # write code here
        res=0
        if n>0:
            while n!=1:
                if n % 2==1:
                    res+=1
                n=n//2
            return res+1
        elif n<0:
            n=-n
            while n != 1:
                if n % 2 == 0:
                    res += 1
                n = n // 2
            return 32-res
        else:
            return 0
class Solution:
    def NumberOf1(self , n: int) -> int:
        # write code here
        res= 0
        B = 32
        while B:
            key = (n >> (B-1)) & 1 ##判断第B为是否为1
            B -= 1
            if key == 1:
                res += 1
        return res