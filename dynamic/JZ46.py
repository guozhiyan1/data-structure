"""
输入: 1223    2,3,4
输出: 5
1 - （1） 1种
12 - （1、2），（12） 2种
122 - （1、2、2），（12、2），（1、22） 3种
1223 - （1、2、2、3），（12、2、3），（1、22、3），（1、2、23），（12、23） 5种
字符串长度满足 0 < n ≤90
1~9译码方式只有一种     10,20译码方式也是只有一种    30，40,50...90,100 0中
11~19   21~26 译码方式有两种，单独译+组合译
27~99 1中译码方式，只能单独译

12=11     dp[i]=dp[i−1]
101  单独   只能组合译（10,1）
108    1           只能组合译（10,8）
109   1   不能单独，只能组合译（10,9）
110    2    只能组合译（1,10）（11）
111   单独译+组合译（11,1）（1,11）  有3种   dp[i] = dp[i - 1] + dp[i - 2]。
用辅助数组dp表示前i个数的译码方法有多少种
对于一个数，我们可以直接译码它，也可以将其与前面的1或者2组合起来译码;
比如88 因为88（xi-1 ~xi）不可被翻译   所以dp[i]=dp[i−1]
比如111 因为11 （xi-1 ~xi）可以被翻译，  所以当整体翻译（xi-1 ~xi），dp[i]=dp[i−2]，当单独翻译xi时，翻译方案数量为dp[i]=dp[i−1]
（xi-1 ~xi）不能被翻译，则dp[i]=dp[i−1]；
（xi-1 ~xi）可以被翻译，在11~26之间，则dp[i] = dp[i - 1] + dp[i - 2]。
"""






class Solution:
    def solve(self , nums: str) -> int:
        #排除0
        if nums == "0":
            return 0
        #排除只有一种可能的10 和 20
        if nums == "10" or nums == "20":
            return 1
        #当0的前面不是1或2时，无法译码，0种
        for i in range(1, len(nums)):
            if nums[i] == '0':
                if nums[i - 1] != '1' and nums[i - 1] != '2':
                    return 0
        #辅助数组初始化为1
        dp = [1 for i in range(len(nums) + 1)]
        for i in range(2, len(nums) + 1):
            #在11-19，21-26之间的情况
            if (nums[i - 2] == '1' and nums[i - 1] != '0') or (nums[i - 2] == '2' and nums[i - 1] > '0' and nums[i - 1] < '7'):
                dp[i] = dp[i - 1] + dp[i - 2]
            else:
                dp[i] = dp[i - 1]
        return dp[len(nums)]

