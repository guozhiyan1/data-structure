"""
孩子们的游戏(圆圈中最后剩下的数)
从0到n-1（首尾相接）中每次去掉第m个数，下一次从去掉数的下一个开始，直到剩下最后一个数
返回的是最后一个数
有数为0的特殊情况
#法一
这是约瑟夫相关问题。
f(n,m)=g(n-1,m)
g(n-1,m)=(f(n-1,m)+m)%n
这两种情况的排列方式不同，一个从0开始报，一个从m开始报，所以我们把第二种情况也排成从0开始报，就是每个人的下标都减少m即可
f(n,m)==(f(n-1,m)+m)%n
某数取余多次与取一次相等，例如5%2=1，而5%2%2%2=1；二、取余运算满足结合律，例如a%n - 1=(a-1)%n (n > 1)；
上面介绍了约瑟夫的相关问题，接下来我们用约瑟夫思想来解决该题。具体的方法如下：首先定义n个人，报m次的解是f(n,m),n,m以及编号为0的小朋友确定了，最后的幸运儿也就确定了，第一次报数后，m-1的小朋友出列，接着从m开始报数，但是最后的解是一样的，令g(n-1,m)表示第二次抽人，解是等于f(n,m)的，这两种情况的排列方式不同，一个从0开始报，一个从m开始报，所以我们把第二种情况也排成从0开始报，就是每个人的下标都减少m即可，那么最后的幸运儿加上m，就得出在原来序列的下标了，解就是f(n-1,m)+m，构成了一个递归问题。但由于是一个循环的环，超出环从头排起，就对每一次环的长度进行取余。关系式为f(n,m) = (f(n-1,m) + m)%n
"""
import sys
sys.setrecursionlimit(100000)
class Solution:
    def function(self, n: int, m: int) -> int:
        if n == 1:
            return 0
        #递归
        x = self.function(n - 1, m)
        #返回最后删除的那个元素
        return (m + x) % n

    def LastRemaining_Solution(self , n: int, m: int) -> int:
        #没有小朋友的情况
        if n == 0 or m == 0:
            return -1
        return self.function(n, m)
